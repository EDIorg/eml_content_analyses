[["index.html", "Analyze Metadata Content 1 Analyze EML Content", " Analyze Metadata Content Corinna Gries 2021-11-05 1 Analyze EML Content This repository is a collection of code examples to analyzes metadata content in EML files. EML files may be analyzed separately to evaluate FAIR or for a whole group of EML files (e.g., all metadata at a research site or project). Other examples included will display the distribution of years of observation, i.e., length of datasets. It is also possible to analyze subject categories of datasets and their download frequency. "],["EML_FAIR.html", "2 Evaluate metadata content against FAIR criteria 2.1 Introduction 2.2 Download EML files 2.3 Analyze EML content", " 2 Evaluate metadata content against FAIR criteria 2.1 Introduction FAIR - findable, accessible, interoperable, reusable, as first suggested by Wilkinson et al. 20161 is a framework for understanding quality of metadata in terms of making data usable for somebody who was not directly involved in the sampling. EDI has implemented the EML schema for metadata and a congruence checker which together already assure a high degree of metadata quality. As the community develops more guidelines for metadata quality it may become interesting for a research site or project to evaluate their overall performance in this area and to analyze where improvements may be implemented. The Research Data Alliance (RDA) has developed guidelines for evaluating FAIR, the FAIR data maturity model. This framework is fairly general and research communities need to expand it with more specific community level criteria. DataONE has taken the initiative to develop such criteria for data in the DataONE community. Specific implementation of the checks for EML metadata can be found in the git repo. Table 1: Comparison of FAIR criteria and how they are implemented in EDI FAIR RDA DataONE EDI repository implementation EML schema EDI check F Metadata is identified by a persistent identifier metadata identifier present required yes F Data is identified by a persistent identifier entity identifier present no F Metadata is identified by a globally unique identifier metadata identifier present required yes F Data is identified by a globally unique identifier entity identifier present no F entity identifierType present no F Rich metadata is provided to allow discovery resource titleLength sufficient yes F resource publicationDate present yes F resource creator present required yes F resource creatorIdentifier present no F resource abstractLength sufficient yes F resource keywords present yes F resource keywords controlled no F resource keywordType present no F resource publicationDate timeframe no F resource revisionDate present not in EML = latest publication date no F resource spatialExtent present yes F geographic description present required with spatialExtent yes F resource taxonomicExtent present yes F resource temporalExtent present yes F Metadata includes the identifier for the data entity identifier present no F Metadata is offered in such a way that it can be harvested and indexed D1 member node, PASTA+ API, schema.org A Metadata contains information to enable the user to get access to the data entity distributionURL resolvable yes A resource accessControlRules present no A resource distributionContact present required yes A resource distributionContactIdentifier present no A resource publisher present is EDI A resource publisherIdentifier present EDIs ROR A resource serviceLocation present PASTA+ API not in EML A resource serviceProvider present PASTA+ API not in EML A Metadata can be accessed manually (i.e. with human intervention) resource landingPage present EDI provided A Data can be accessed manually (i.e. with human intervention) entity distributionURL resolvable yes A Metadata identifier resolves to a metadata record metadata identifier resolvable no A Data identifier resolves to a digital object A Metadata is accessed through standardised protocol yes A Data is accessible through standardised protocol yes A Data can be accessed automatically (i.e. by a computer program) yes A Metadata is accessible through a free access protocol yes A Data is accessible through a free access protocol yes A Data is accessible through an access protocol that supports authentication and authorisation yes A Metadata is guaranteed to remain available after data is no longer available I Metadata uses knowledge representation expressed in standardised format LTER vocabulary I Data uses knowledge representation expressed in standardised format EML entity I entity format present yes I entity name present required yes I entity type present encoded yes I entity checksum present yes I entity attributeName differs from description yes I entity attributeNames unique yes I entity attributeDefinition present no I entity attributeDefinition sufficient no I entity attributeStorageType present no I Metadata uses machine-understandable knowledge representation LTER vocabulary in SKOS I Data uses machine-understandable knowledge representation data models I Metadata uses FAIR-compliant vocabularies LTER vocabulary I Data uses FAIR-compliant vocabularies I Metadata includes references to other metadata I Data includes references to other data I Metadata includes references to other data I Data includes qualified references to other data I Metadata includes qualified references to other metadata I Metadata include qualified references to other data R Plurality of accurate and relevant attributes are provided to allow reuse entity format nonproprietary R entity attributeDomain present R entity attributeUnits present required yes R entity attributeMeasurementScale present required yes R entity attributePrecision present R entity description present required yes R entity qualityDescription present R Metadata includes information about the licence under which the data can be reused resource license present R Metadata refers to a standard reuse licence R Metadata refers to a machine-understandable reuse licence R Metadata includes provenance information according to community-specific standards provenance processStepCode present R provenance sourceEntity present R provenance trace present not in EML R resource methods present yes R Metadata includes provenance information according to a cross-community language R Metadata complies with a community standard EML yes R Data complies with a community standard R Metadata is expressed in compliance with a machine-understandable community standard EML yes R Data is expressed in compliance with a machine-understandable community standard 2.2 Download EML files For more information see the EDIutils R package, e.g. how to find all package IDs for a site or by keyword library(EDIutils) library(xml2) library(stringr) scope &lt;- &quot;knb-lter-ntl&quot; identifier &lt;- 1 #find the newest revision revision &lt;- list_data_package_revisions(scope = scope, identifier = identifier, filter = &quot;newest&quot;, tier = &quot;production&quot;) package_id &lt;- paste(scope,identifier,revision, sep = &quot;.&quot;) # Read the EML file for the data package ID and save EML locally. eml_file &lt;- read_metadata(packageId = package_id) #write_xml(eml_file, file = paste(&quot;./data/&quot;, package_id, &quot;xml&quot;, sep = &quot;.&quot;)) 2.3 Analyze EML content These checks are not comprehensive. Checks for semantic annotations are not implemented here yet. 2.3.1 title length eml_title &lt;- xml_text(xml_find_first(eml_file, &#39;.//title&#39;)) title_words &lt;- str_split(eml_title, &#39;\\\\s+&#39;) title_length &lt;- length(title_words[[1]]) 2.3.2 abstract length eml_abstract &lt;- xml_text(xml_find_first(eml_file, &#39;.//abstract&#39;)) eml_abstract &lt;- str_replace_all(eml_abstract, &#39;\\\\\\n&#39;, &#39; &#39;) eml_abstract &lt;- str_remove_all(eml_abstract, &#39;\\\\\\t&#39;) abstract_words &lt;- str_split(eml_abstract, &#39;\\\\s+&#39;) abstract_length &lt;- length(abstract_words[[1]]) 2.3.3 number of keywords, keyword types, keyword thesaurus eml_keywordsets &lt;- xml_find_all(eml_file,&#39;.//keywordSet&#39;) eml_keywords &lt;- xml_find_all(eml_keywordsets, &#39;.//keyword&#39;) num_keywords &lt;- length(eml_keywords) eml_keyword_attr &lt;- xml_has_attr(eml_keywords, &#39;keywordType&#39;) num_keywordtype &lt;- length(which(eml_keyword_attr)) eml_thesaurus &lt;- xml_find_all(eml_keywordsets, &#39;.//keywordThesaurus&#39;) num_thesaurus &lt;- length(eml_thesaurus) 2.3.4 pub date eml_pubdate &lt;- xml_text(xml_find_first(eml_file, &#39;.//pubDate&#39;)) #creator and orcid ID eml_creators &lt;- xml_find_all(eml_file, &#39;./dataset/creator&#39;) num_creators &lt;- length(eml_creators) num_orcids &lt;- 0 if (num_creators &gt; 0){ for (j in 1:length(eml_creators)) { eml_userid &lt;- xml_find_first(eml_creators[j], &#39;.//userId&#39;) if (!is.na(eml_userid)){ num_orcids &lt;- num_orcids + 1 } } } 2.3.5 coverages present eml_geog_num &lt;- length(xml_find_all(eml_file, &#39;.//geographicCoverage&#39;)) if (eml_geog_num &gt; 0) {eml_geog &lt;- &quot;yes&quot;} else {eml_geog &lt;- &quot;no&quot;} eml_geog_descr_num &lt;- length(xml_find_all(eml_file, &#39;.//geographicDescription&#39;)) if (eml_geog_descr_num == eml_geog_num) {eml_geog_descr &lt;- &quot;yes&quot;} else {eml_geog_descr &lt;- &quot;no&quot;} eml_time_num &lt;- length(xml_find_all(eml_file, &#39;.//temporalCoverage&#39;)) if (eml_time_num &gt; 0) {eml_time &lt;- &quot;yes&quot;} else {eml_time &lt;- &quot;no&quot;} eml_taxon_num &lt;- length(xml_find_all(eml_file, &#39;.//taxonomicCoverage&#39;)) if (eml_taxon_num &gt; 0 ) {eml_taxon &lt;- &quot;yes&quot;} else {eml_taxon &lt;- &quot;no&quot;} 2.3.6 access is public eml_access &lt;- xml_text(xml_find_all(eml_file, &#39;./access/allow/principal&#39;)) eml_public &lt;- str_detect(eml_access, &#39;public&#39;) public_num &lt;- length(which(eml_public)) if (public_num &gt; 0) {public &lt;- &quot;yes&quot;} else {public &lt;- &quot;no&quot;} 2.3.7 contact and contact ID present eml_contact &lt;- length(xml_find_all(eml_file, &#39;./dataset/contact/electronicMailAddress&#39;)) eml_contact_id &lt;- length(xml_find_all(eml_file, &#39;./dataset/contact/userId&#39;)) 2.3.8 quality description present num_qualitydesc &lt;- length(xml_find_all(eml_file, &#39;//qualityControl&#39;)) 2.3.9 methods description length eml_methods &lt;- xml_text(xml_find_all(eml_file, &#39;//methods&#39;)) if (length(eml_methods) &gt; 0){ eml_methods &lt;- str_replace_all(eml_methods, &#39;\\\\\\n&#39;, &#39; &#39;) eml_methods &lt;- str_remove_all(eml_methods, &#39;\\\\\\t&#39;) eml_methods_word &lt;- str_split(eml_methods, &#39;\\\\s+&#39;) methods_length &lt;- length(eml_methods_word[[1]]) } 2.3.10 license present num_license &lt;- length(xml_find_all(eml_file, &#39;//intellectualRights&#39;)) num_license &lt;- num_license + length(xml_find_all(eml_file, &#39;//licensed&#39;)) 2.3.11 provenance data source present num_provdatasource &lt;- length(xml_find_all(eml_file, &#39;//dataSource&#39;)) 2.3.12 processing code present/described num_software &lt;- length(xml_find_all(eml_file, &#39;//software&#39;)) eml_script &lt;- xml_text(xml_find_all(eml_file, &#39;//otherEntity/physical/objectName&#39;)) extensions &lt;- character(0) extensions_to_check &lt;- c(&#39;R&#39;, &#39;r&#39;, &#39;py&#39;, &#39;sql&#39;) script &lt;- &#39;no&#39; if (length(eml_script) &gt; 0){ for (j in 1:length(eml_script)) { eml_scriptparts &lt;- str_split(eml_script[j], &#39;\\\\.&#39;) p &lt;- length(eml_scriptparts[[1]]) extensions &lt;- append(extensions, eml_scriptparts[[1]][p]) } for (j in 1:length(extensions_to_check)) { if(extensions_to_check[j] %in% extensions){ script &lt;- &#39;yes&#39; } } } 2.3.13 entity information eml_entities &lt;- xml_find_all(eml_file, &#39;.//entityName&#39;) num_entities &lt;- length(eml_entities) eml_entity_info &lt;- xml_siblings(eml_entities) num_entity_url &lt;- length(xml_find_all(eml_entity_info, &#39;./distribution/online/url&#39;)) num_checksum &lt;- length(xml_find_all(eml_entity_info, &#39;./authentication[1]&#39;)) num_entitydescr &lt;- length(xml_find_all(eml_entity_info, &#39;//entityDescription&#39;)) num_enitydescrsufficient &lt;- 0 if (num_entitydescr &gt; 0){ eml_entitydescr &lt;- xml_text(xml_find_all(eml_entity_info, &#39;//entityDescription&#39;)) for (j in 1:num_entitydescr) { entitydescr_words &lt;- str_split(eml_entitydescr[j], &#39;\\\\s+&#39;) if (length(entitydescr_words[[1]]) &gt; 2){ num_enitydescrsufficient &lt;- num_enitydescrsufficient + 1 } } } num_entity_format &lt;- length(xml_find_all(eml_entity_info, &#39;//physical/dataFormat&#39;)) entity_ids &lt;- vector() for (j in 1:num_entities) { entity &lt;- xml_parent(eml_entities[j]) entity_ids[j] &lt;- xml_attr(xml_parent(eml_entities[j]), &#39;id&#39;) } entity_ids &lt;- !is.na(entity_ids) if (entity_ids == TRUE) { num_entity_id &lt;- length(entity_ids) } else {num_entity_id = 0} num_otherentity &lt;- length(xml_find_all(eml_file, &#39;//otherEntity&#39;)) 2.3.14 table entity specific information eml_tableentities &lt;- xml_find_all(eml_file, &#39;.//dataTable&#39;) num_tables &lt;- length(eml_tableentities) 2.3.15 attribute information num_attributes &lt;- 0 num_attributedefs &lt;- 0 num_attrdefsufficient &lt;- 0 num_attributedefdifferent &lt;- 0 num_attributestoragetype &lt;- 0 attr_names &lt;- c(&#39;&#39;) attr_nameunique &lt;- 0 if (length(eml_tableentities) &gt; 0){ for (j in 1:length(eml_tableentities)){ eml_attributes &lt;- xml_find_all(eml_tableentities[j], &#39;.//attribute&#39;) num_attributes &lt;- num_attributes + length(eml_attributes) num_attributedefs &lt;- num_attributedefs + length(xml_find_all(eml_attributes, &#39;./attributeDefinition&#39;)) num_attributestoragetype &lt;- num_attributestoragetype + length(xml_find_all(eml_attributes, &#39;./storageType&#39;)) if (length(eml_attributes) &gt; 0){ for (k in 1:length(eml_attributes)) { eml_attributename &lt;- xml_text(xml_find_first(eml_attributes[k], &#39;./attributeName&#39;)) eml_attributedef &lt;- xml_text(xml_find_first(eml_attributes[k], &#39;./attributeDefinition&#39;)) if (eml_attributedef != eml_attributename){ num_attributedefdifferent &lt;- num_attributedefdifferent + 1 } attr_names &lt;- append(attr_names, eml_attributename) attrdef_words &lt;- str_split(eml_attributedef, &#39;\\\\s+&#39;) attrdef_length &lt;- length(attrdef_words[[1]]) if (attrdef_length &gt; 2){ num_attrdefsufficient &lt;- num_attrdefsufficient + 1 } } } } if (length(unique(attr_names)) == length(attr_names)){ attr_nameunique &lt;- 1 } } test &lt;- c(&quot;package ID&quot;, &quot;number of words in title&quot;, &quot;number of words in abstract&quot;, &quot;number of keywords&quot;, &quot;number of keywords with type&quot;, &quot;thesauri identified&quot;, &quot;publication date present&quot;, &quot;number of creators&quot;, &quot;number of creators with ID&quot;, &quot;geographic coverage present&quot;, &quot;geografic description present&quot;, &quot;temporal coverage present&quot;, &quot;taxononimc coverage present&quot;, &quot;public access granted&quot;, &quot;number of dataset contacts&quot;, &quot;number of contacts with ID&quot;, &quot;number of words in methods description&quot;, &quot;processing code in software element&quot;, &quot;processing code in other entity&quot;, &quot;license present&quot;, &quot;provenance datasource linked&quot;, &quot;number of table entities&quot;, &quot;number of other entities&quot;, &quot;number of all entities&quot;, &quot;number of entity IDs present&quot;, &quot;number of entitis downloadable&quot;, &quot;number of entities with checksums&quot;, &quot;number of entities with descriptions&quot;, &quot;number of enity description of sufficient length&quot;, &quot;number of entities with format defined&quot;, &quot;attribute names unique within each entity&quot;, &quot;number of attributes&quot;, &quot;number of attribute definitions&quot;, &quot;number of attribute definitions of sufficient length&quot;, &quot;attribute definition different then attribute name&quot;, &quot;attribute storage type defined&quot;, &quot;number of data quality descriptions&quot;) result &lt;- c(package_id, title_length, abstract_length, num_keywords, num_keywordtype, num_thesaurus, eml_pubdate, num_creators, num_orcids, eml_geog, eml_geog_descr, eml_time, eml_taxon, public, eml_contact, eml_contact_id, methods_length, num_software, script, num_license, num_provdatasource, num_tables, num_otherentity, num_entities, num_entity_id, num_entity_url, num_checksum, num_entitydescr, num_enitydescrsufficient, num_entity_format, attr_nameunique, num_attributes, num_attributedefs, num_attrdefsufficient, num_attributedefdifferent, num_attributestoragetype, num_qualitydesc) evaluation &lt;- data.frame(test, result) knitr::kable(evaluation, table.attr = &quot;class=\\&quot;striped\\&quot;&quot;, format = &quot;html&quot;) test result package ID knb-lter-ntl.1.52 number of words in title 17 number of words in abstract 206 number of keywords 41 number of keywords with type 0 thesauri identified 5 publication date present 2010-09-20 number of creators 4 number of creators with ID 2 geographic coverage present yes geografic description present yes temporal coverage present yes taxononimc coverage present no public access granted yes number of dataset contacts 2 number of contacts with ID 0 number of words in methods description 635 processing code in software element 0 processing code in other entity no license present 1 provenance datasource linked 0 number of table entities 1 number of other entities 0 number of all entities 1 number of entity IDs present 0 number of entitis downloadable 1 number of entities with checksums 1 number of entities with descriptions 1 number of enity description of sufficient length 1 number of entities with format defined 1 attribute names unique within each entity 1 number of attributes 59 number of attribute definitions 59 number of attribute definitions of sufficient length 51 attribute definition different then attribute name 59 attribute storage type defined 31 number of data quality descriptions 0 Wilkinson, M., Dumontier, M., Aalbersberg, I. et al. The FAIR Guiding Principles for scientific data management and stewardship. Sci Data 3, 160018 (2016). https://doi.org/10.1038/sdata.2016.18 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
