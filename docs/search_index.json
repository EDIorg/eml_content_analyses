[["index.html", "Analyze Metadata Content 1 Analyze EML Content", " Analyze Metadata Content Corinna Gries 2022-05-06 1 Analyze EML Content This repository is a collection of code examples to analyzes metadata content in EML files. EML files may be analyzed separately to evaluate FAIR or for a whole group of EML files (e.g., all metadata at a research site or project). Other examples included will display the distribution of years of observation, i.e., length of datasets. It is also possible to analyze subject categories of datasets and their download frequency. "],["EML_FAIR.html", "2 Evaluate metadata content against FAIR criteria 2.1 Introduction 2.2 Download EML files 2.3 Analyze EML content", " 2 Evaluate metadata content against FAIR criteria 2.1 Introduction FAIR - findable, accessible, interoperable, reusable, as first suggested by Wilkinson et al. 20161 is a framework for understanding quality of metadata in terms of making data usable for somebody who was not directly involved in the sampling. EDI has implemented the EML schema for metadata and a congruence checker which together already assure a high degree of metadata quality. As the community develops more guidelines for metadata quality it may become interesting for a research site or project to evaluate their overall performance in this area and to analyze where improvements may be implemented. The Research Data Alliance (RDA) has developed guidelines for evaluating FAIR, the FAIR data maturity model. This framework is fairly general and research communities need to expand it with more specific community level criteria. DataONE has taken the initiative to develop such criteria for data in the DataONE community. Specific implementation of the checks for EML metadata can be found in the git repo. Table 1: Comparison of FAIR criteria and how they are implemented in EDI FAIR RDA DataONE EDI repository implementation EML schema EDI check F Metadata is identified by a persistent identifier metadata identifier present required yes F Data is identified by a persistent identifier entity identifier present yes F Metadata is identified by a globally unique identifier metadata identifier present required yes F Data is identified by a globally unique identifier entity identifier present yes F entity identifier Type present yes F Rich metadata is provided to allow discovery resource title length sufficient yes F resource publication date present yes F resource creator present required yes F resource creator identifier present no F resource abstract length sufficient yes F resource keywords present yes F resource keywords controlled no F resource keyword type present no F resource publication date timeframe no F resource revision date present not in EML = latest publication date no F resource spatial extent present yes F geographic description present required with spatial extent yes F resource taxonomic extent present yes F resource temporal extent present yes F Metadata includes the identifier for the data entity identifier present yes F Metadata is offered in such a way that it can be harvested and indexed D1 member node, PASTA+ API, schema.org A Metadata contains information to enable the user to get access to the data entity distribution URL resolvable yes A resource access control rules present yes no A resource distribution contact present required yes A resource distribution contact identifier present no A resource publisher present is EDI A resource publisher identifier present EDIs ROR A resource service location present PASTA+ API not in EML A resource service provider present PASTA+ API not in EML A Metadata can be accessed manually (i.e. with human intervention) resource landing page present yes A Data can be accessed manually (i.e. with human intervention) entity distribution URL resolvable yes yes A Metadata identifier resolves to a metadata record metadata identifier resolvable no A Data identifier resolves to a digital object yes A Metadata is accessed through standardized protocol yes A Data is accessible through standardized protocol yes A Data can be accessed automatically (i.e. by a computer program) yes A Metadata is accessible through a free access protocol yes A Data is accessible through a free access protocol yes A Data is accessible through an access protocol that supports authentication and authorisation yes A Metadata is guaranteed to remain available after data is no longer available I Metadata uses knowledge representation expressed in standardised format LTER vocabulary I Data uses knowledge representation expressed in standardised format EML entity I entity format present yes I entity name present required yes I entity type present encoded yes I entity checksum present yes I entity attributeName differs from description yes I entity attributeNames unique yes I entity attributeDefinition present no I entity attributeDefinition sufficient no I entity attributeStorageType present no I Metadata uses machine-understandable knowledge representation LTER vocabulary in SKOS I Data uses machine-understandable knowledge representation data models I Metadata uses FAIR-compliant vocabularies LTER vocabulary I Data uses FAIR-compliant vocabularies I Metadata includes references to other metadata I Data includes references to other data I Metadata includes references to other data I Data includes qualified references to other data I Metadata includes qualified references to other metadata I Metadata include qualified references to other data R Plurality of accurate and relevant attributes are provided to allow reuse entity format nonproprietary R entity attributeDomain present R entity attributeUnits present required yes R entity attributeMeasurementScale present required yes R entity attributePrecision present R entity description present required yes R entity qualityDescription present R Metadata includes information about the licence under which the data can be reused resource license present yes R Metadata refers to a standard reuse licence R Metadata refers to a machine-understandable reuse licence R Metadata includes provenance information according to community-specific standards provenance processStepCode present R provenance sourceEntity present R provenance trace present not in EML R resource methods present yes R Metadata includes provenance information according to a cross-community language R Metadata complies with a community standard EML yes R Data complies with a community standard R Metadata is expressed in compliance with a machine-understandable community standard EML yes R Data is expressed in compliance with a machine-understandable community standard 2.2 Download EML files For more information see the EDIutils R package, e.g. how to find all package IDs for a site or by keyword library(EDIutils) library(xml2) library(stringr) scope &lt;- &quot;knb-lter-ntl&quot; identifier &lt;- 1 #find the newest revision revision &lt;- list_data_package_revisions(scope = scope, identifier = identifier, filter = &quot;newest&quot;) package_id &lt;- paste(scope,identifier,revision, sep = &quot;.&quot;) # Read the EML file for the data package ID and save EML locally. eml_file &lt;- read_metadata(packageId = package_id) #write_xml(eml_file, file = paste(&quot;./data/&quot;, package_id, &quot;xml&quot;, sep = &quot;.&quot;)) 2.3 Analyze EML content These checks are not comprehensive. Checks for semantic annotations are not implemented here yet. 2.3.1 dataset has ID and ID is resolvable We know that all datasets in EDI have a metadata ID for valid EML, however, that ID is not resolvable. This checks to see if there is an alternateIdentifier that is resolvable. One possible ID is the EDI inserted DOI, but others are possible as well. eml_alt_id &lt;- xml_text(xml_find_all(eml_file, &#39;./dataset/alternateIdentifier&#39;)) eml_alt_id_syst &lt;- xml_find_all(eml_file, &#39;./dataset/alternateIdentifier&#39;) %&gt;% xml_attr(&#39;system&#39;) eml_alt_id &lt;- str_remove(eml_alt_id, &#39;doi:&#39;) eml_id_text &lt;- paste(eml_alt_id_syst, eml_alt_id, sep = &#39;/&#39;) eml_id_resolv &lt;- ifelse(str_detect(eml_id_text, &quot;https://|http://&quot;), 1, 0) 2.3.2 title length eml_title &lt;- xml_text(xml_find_first(eml_file, &#39;.//title&#39;)) title_words &lt;- str_split(eml_title, &#39;\\\\s+&#39;) title_length &lt;- length(title_words[[1]]) 2.3.3 abstract length eml_abstract &lt;- xml_text(xml_find_first(eml_file, &#39;.//abstract&#39;)) eml_abstract &lt;- str_replace_all(eml_abstract, &#39;\\\\\\n&#39;, &#39; &#39;) eml_abstract &lt;- str_remove_all(eml_abstract, &#39;\\\\\\t&#39;) abstract_words &lt;- str_split(eml_abstract, &#39;\\\\s+&#39;) abstract_length &lt;- length(abstract_words[[1]]) 2.3.4 number of keywords, keyword types, keyword thesaurus eml_keywordsets &lt;- xml_find_all(eml_file,&#39;.//keywordSet&#39;) eml_keywords &lt;- xml_find_all(eml_keywordsets, &#39;.//keyword&#39;) num_keywords &lt;- length(eml_keywords) eml_keyword_attr &lt;- xml_has_attr(eml_keywords, &#39;keywordType&#39;) num_keywordtype &lt;- length(which(eml_keyword_attr)) eml_thesaurus &lt;- xml_find_all(eml_keywordsets, &#39;.//keywordThesaurus&#39;) num_thesaurus &lt;- length(eml_thesaurus) 2.3.5 pub date eml_pubdate &lt;- xml_text(xml_find_first(eml_file, &#39;.//pubDate&#39;)) #creator and orcid ID eml_creators &lt;- xml_find_all(eml_file, &#39;./dataset/creator&#39;) num_creators &lt;- length(eml_creators) num_orcids &lt;- 0 if (num_creators &gt; 0){ for (j in 1:length(eml_creators)) { eml_userid &lt;- xml_find_first(eml_creators[j], &#39;.//userId&#39;) if (!is.na(eml_userid)){ num_orcids &lt;- num_orcids + 1 } } } 2.3.6 coverages present eml_geog_num &lt;- length(xml_find_all(eml_file, &#39;.//geographicCoverage&#39;)) if (eml_geog_num &gt; 0) {eml_geog &lt;- &quot;yes&quot;} else {eml_geog &lt;- &quot;no&quot;} eml_geog_descr_num &lt;- length(xml_find_all(eml_file, &#39;.//geographicDescription&#39;)) if (eml_geog_descr_num == eml_geog_num) {eml_geog_descr &lt;- &quot;yes&quot;} else {eml_geog_descr &lt;- &quot;no&quot;} eml_time_num &lt;- length(xml_find_all(eml_file, &#39;.//temporalCoverage&#39;)) if (eml_time_num &gt; 0) {eml_time &lt;- &quot;yes&quot;} else {eml_time &lt;- &quot;no&quot;} eml_taxon_num &lt;- length(xml_find_all(eml_file, &#39;.//taxonomicCoverage&#39;)) if (eml_taxon_num &gt; 0 ) {eml_taxon &lt;- &quot;yes&quot;} else {eml_taxon &lt;- &quot;no&quot;} 2.3.7 access is public eml_access &lt;- xml_text(xml_find_all(eml_file, &#39;./access/allow/principal&#39;)) eml_public &lt;- str_detect(eml_access, &#39;public&#39;) public_num &lt;- length(which(eml_public)) if (public_num &gt; 0) {public &lt;- &quot;yes&quot;} else {public &lt;- &quot;no&quot;} 2.3.8 contact and contact ID present eml_contact &lt;- length(xml_find_all(eml_file, &#39;./dataset/contact/electronicMailAddress&#39;)) eml_contact_id &lt;- length(xml_find_all(eml_file, &#39;./dataset/contact/userId&#39;)) 2.3.9 publisher and publisher ID present this is automatically added by EDI eml_publisher &lt;- length(xml_find_all(eml_file, &#39;./dataset/publisher&#39;)) eml_publisher_id &lt;- length(xml_find_all(eml_file, &#39;./dataset/publisher/userID&#39;)) 2.3.10 landing page link present eml_landing &lt;- xml_text(xml_find_all(eml_file, &#39;./dataset/distribution/online/url[@function=&quot;information&quot;]&#39;)) eml_landing &lt;- ifelse(length(eml_landing &gt; 0), eml_landing, &quot;&quot;) eml_landing_resolv &lt;- ifelse(str_detect(eml_landing, &quot;https://|http://&quot;), 1, 0) 2.3.11 quality description present num_qualitydesc &lt;- length(xml_find_all(eml_file, &#39;//qualityControl&#39;)) 2.3.12 methods description present and length eml_methods &lt;- xml_text(xml_find_all(eml_file, &#39;//methods&#39;)) if (length(eml_methods) &gt; 0){ eml_methods &lt;- str_replace_all(eml_methods, &#39;\\\\\\n&#39;, &#39; &#39;) eml_methods &lt;- str_remove_all(eml_methods, &#39;\\\\\\t&#39;) eml_methods_word &lt;- str_split(eml_methods, &#39;\\\\s+&#39;) methods_length &lt;- length(eml_methods_word[[1]]) } 2.3.13 license present num_license &lt;- length(xml_find_all(eml_file, &#39;//intellectualRights&#39;)) num_license &lt;- num_license + length(xml_find_all(eml_file, &#39;//licensed&#39;)) 2.3.14 provenance data source present num_provdatasource &lt;- length(xml_find_all(eml_file, &#39;//dataSource&#39;)) 2.3.15 processing code present and described This checks for certain file extensions num_software &lt;- length(xml_find_all(eml_file, &#39;//software&#39;)) eml_script &lt;- xml_text(xml_find_all(eml_file, &#39;//otherEntity/physical/objectName&#39;)) extensions &lt;- character(0) extensions_to_check &lt;- c(&#39;R&#39;, &#39;r&#39;, &#39;py&#39;, &#39;sql&#39;) script &lt;- &#39;no&#39; if (length(eml_script) &gt; 0){ for (j in 1:length(eml_script)) { eml_scriptparts &lt;- str_split(eml_script[j], &#39;\\\\.&#39;) p &lt;- length(eml_scriptparts[[1]]) extensions &lt;- append(extensions, eml_scriptparts[[1]][p]) } for (j in 1:length(extensions_to_check)) { if(extensions_to_check[j] %in% extensions){ script &lt;- &#39;yes&#39; } } } 2.3.16 entity information eml_entities &lt;- xml_find_all(eml_file, &#39;.//entityName&#39;) num_entities &lt;- length(eml_entities) eml_entity_info &lt;- xml_siblings(eml_entities) num_entity_url &lt;- length(xml_find_all(eml_entity_info, &#39;./distribution/online/url&#39;)) num_checksum &lt;- length(xml_find_all(eml_entity_info, &#39;./authentication[1]&#39;)) num_entitydescr &lt;- length(xml_find_all(eml_entity_info, &#39;//entityDescription&#39;)) num_enitydescrsufficient &lt;- 0 if (num_entitydescr &gt; 0){ eml_entitydescr &lt;- xml_text(xml_find_all(eml_entity_info, &#39;//entityDescription&#39;)) for (j in 1:num_entitydescr) { entitydescr_words &lt;- str_split(eml_entitydescr[j], &#39;\\\\s+&#39;) if (length(entitydescr_words[[1]]) &gt; 2){ num_enitydescrsufficient &lt;- num_enitydescrsufficient + 1 } } } num_entity_format &lt;- length(xml_find_all(eml_entity_info, &#39;//physical/dataFormat&#39;)) entity_ids_text &lt;- xml_attr(xml_parent(eml_entities), &#39;id&#39;) entity_syst_text &lt;- xml_attr(xml_parent(eml_entities), &#39;system&#39;) entity_ids &lt;- length(entity_ids_text[!is.na(entity_ids_text)]) entity_syst &lt;- length(entity_syst_text[!is.na(entity_syst_text)]) entity_alt_ids &lt;- length(xml_find_all(xml_parent(eml_entity_info), &#39;./alternateIdentifier&#39;)) entity_ids &lt;- entity_ids + entity_alt_ids num_entity_id &lt;- ifelse(entity_ids &gt; num_entities, num_entities, entity_ids) entity_alt_syst &lt;- length(xml_find_all(xml_parent(eml_entity_info), &#39;./alternateIdentifier[@system]&#39;)) entity_syst &lt;- entity_syst + entity_alt_syst num_entity_syst &lt;- ifelse(entity_syst &gt; num_entities, num_entities, entity_syst) num_otherentity &lt;- length(xml_find_all(eml_file, &#39;//otherEntity&#39;)) 2.3.17 table entity specific information eml_tableentities &lt;- xml_find_all(eml_file, &#39;.//dataTable&#39;) num_tables &lt;- length(eml_tableentities) 2.3.18 attribute information num_attributes &lt;- 0 num_attributedefs &lt;- 0 num_attrdefsufficient &lt;- 0 num_attributedefdifferent &lt;- 0 num_attributestoragetype &lt;- 0 attr_nameunique &lt;- 0 num_attributeprecision &lt;- 0 if (length(eml_tableentities) &gt; 0){ for (j in 1:length(eml_tableentities)){ eml_attributes &lt;- xml_find_all(eml_tableentities[j], &#39;.//attribute&#39;) num_attributes &lt;- num_attributes + length(eml_attributes) num_attributedefs &lt;- num_attributedefs + length(xml_find_all(eml_attributes, &#39;./attributeDefinition&#39;)) num_attributeprecision &lt;- num_attributeprecision + length(xml_find_all(eml_attributes, &#39;./measurementScale/interval/precision&#39;)) num_attributeprecision &lt;- num_attributeprecision + length(xml_find_all(eml_attributes, &#39;./measurementScale/ratio/precision&#39;)) num_attributeprecision &lt;- num_attributeprecision + length(xml_find_all(eml_attributes, &#39;./measurementScale/dateTime/dateTimePrecision&#39;)) num_attributestoragetype &lt;- num_attributestoragetype + length(xml_find_all(eml_attributes, &#39;./storageType&#39;)) attr_names &lt;- c(&#39;&#39;) if (length(eml_attributes) &gt; 0){ for (k in 1:length(eml_attributes)) { eml_attributename &lt;- xml_text(xml_find_first(eml_attributes[k], &#39;./attributeName&#39;)) eml_attributedef &lt;- xml_text(xml_find_first(eml_attributes[k], &#39;./attributeDefinition&#39;)) if (eml_attributedef != eml_attributename){ num_attributedefdifferent &lt;- num_attributedefdifferent + 1 } attr_names &lt;- append(attr_names, eml_attributename) attrdef_words &lt;- str_split(eml_attributedef, &#39;\\\\s+&#39;) attrdef_length &lt;- length(attrdef_words[[1]]) if (attrdef_length &gt; 2){ num_attrdefsufficient &lt;- num_attrdefsufficient + 1 } } } if (length(unique(attr_names)) == length(attr_names)){ attr_nameunique &lt;- 1 } } } test &lt;- c(&quot;package ID&quot;, &quot;dataset ID resolvable&quot;, &quot;number of words in title&quot;, &quot;number of words in abstract&quot;, &quot;number of keywords&quot;, &quot;number of keywords with type&quot;, &quot;thesauri identified&quot;, &quot;publication date present&quot;, &quot;number of creators&quot;, &quot;number of creators with ID&quot;, &quot;geographic coverage present&quot;, &quot;geographic description present&quot;, &quot;temporal coverage present&quot;, &quot;taxononimc coverage present&quot;, &quot;public access granted&quot;, &quot;number of dataset contacts&quot;, &quot;number of contacts with ID&quot;, &quot;number of publishers&quot;, &quot;number of publisher with ID&quot;, &quot;landing page link&quot;, &quot;number of words in methods description&quot;, &quot;processing code in software element&quot;, &quot;processing code in other entity&quot;, &quot;license present&quot;, &quot;provenance datasource linked&quot;, &quot;number of table entities&quot;, &quot;number of other entities&quot;, &quot;number of all entities&quot;, &quot;number of entity IDs present&quot;, &quot;number of entitis downloadable&quot;, &quot;number of entities with checksums&quot;, &quot;number of entities with descriptions&quot;, &quot;number of enity description of sufficient length&quot;, &quot;number of entities with format defined&quot;, &quot;attribute names unique within each entity&quot;, &quot;number of attributes&quot;, &quot;number of attribute definitions&quot;, &quot;number of attribute definitions of sufficient length&quot;, &quot;attribute definition different then attribute name&quot;, &quot;attribute storage type defined&quot;, &quot;attribute precision defined&quot;, &quot;number of data quality descriptions&quot;) result &lt;- c(package_id, eml_id_text, title_length, abstract_length, num_keywords, num_keywordtype, num_thesaurus, eml_pubdate, num_creators, num_orcids, eml_geog, eml_geog_descr, eml_time, eml_taxon, public, eml_contact, eml_contact_id, eml_publisher, eml_publisher_id, eml_landing, methods_length, num_software, script, num_license, num_provdatasource, num_tables, num_otherentity, num_entities, num_entity_id, num_entity_url, num_checksum, num_entitydescr, num_enitydescrsufficient, num_entity_format, attr_nameunique, num_attributes, num_attributedefs, num_attrdefsufficient, num_attributedefdifferent, num_attributestoragetype, num_attributeprecision, num_qualitydesc) evaluation &lt;- data.frame(test, result) knitr::kable(evaluation, table.attr = &quot;class=\\&quot;striped\\&quot;&quot;, format = &quot;html&quot;) test result package ID knb-lter-ntl.1.52 dataset ID resolvable https://doi.org/10.6073/pasta/8359d27bbd91028f222d923a7936077d number of words in title 17 number of words in abstract 206 number of keywords 41 number of keywords with type 0 thesauri identified 5 publication date present 2010-09-20 number of creators 4 number of creators with ID 2 geographic coverage present yes geographic description present yes temporal coverage present yes taxononimc coverage present no public access granted yes number of dataset contacts 2 number of contacts with ID 0 number of publishers 0 number of publisher with ID 0 landing page link https://test7.limnology.wisc.edu/dataset/north-temperate-lakes-lter-chemical-limnology-primary-study-lakes-nutrients-ph-and-carbon-19 number of words in methods description 635 processing code in software element 0 processing code in other entity no license present 1 provenance datasource linked 0 number of table entities 1 number of other entities 0 number of all entities 1 number of entity IDs present 0 number of entitis downloadable 1 number of entities with checksums 1 number of entities with descriptions 1 number of enity description of sufficient length 1 number of entities with format defined 1 attribute names unique within each entity 1 number of attributes 59 number of attribute definitions 59 number of attribute definitions of sufficient length 51 attribute definition different then attribute name 59 attribute storage type defined 31 attribute precision defined 2 number of data quality descriptions 0 Wilkinson, M., Dumontier, M., Aalbersberg, I. et al. The FAIR Guiding Principles for scientific data management and stewardship. Sci Data 3, 160018 (2016). https://doi.org/10.1038/sdata.2016.18 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
